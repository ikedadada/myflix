import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/app/config/apiClient';
import { AiCopySection } from '@/features/upload/components/AiCopySection';
import { FilePicker } from '@/features/upload/components/FilePicker';
import { RecentUploadsAccordion } from '@/features/upload/components/RecentUploadsAccordion';
import { TextInputs } from '@/features/upload/components/TextInputs';
import { ThumbnailSection } from '@/features/upload/components/ThumbnailSection';
import { useUploadForm } from '@/features/upload/useUploadForm';
import { PageHeader } from '@/shared/components/layout/PageHeader';
import { useUploadSessions } from '@/shared/hooks/useUploadSessions';
import type { VideoSummary } from '@/shared/types/video';
import { Button, Card, CardContent, CardHeader, CardTitle } from '@/shared/ui';

export const UploadPage = () => {
  const client = useQueryClient();
  const { create: createUploadSession, creating } = useUploadSessions();

  const [file, setFile] = useState<File | null>(null);
  const [durationSeconds, setDurationSeconds] = useState<number | null>(null);
  const [suggestedTitle, setSuggestedTitle] = useState<string | undefined>(undefined);
  const [thumbnailSource, setThumbnailSource] = useState<'auto' | 'manual' | null>(null);
  const [thumbnailBlob, setThumbnailBlob] = useState<Blob | null>(null);
  const [thumbnailPreviewUrl, setThumbnailPreviewUrl] = useState<string | null>(null);
  const [thumbnailFileName, setThumbnailFileName] = useState<string | null>(null);
  const [thumbnailError, setThumbnailError] = useState<string | null>(null);
  const [thumbnailObjectKey, setThumbnailObjectKey] = useState<string | null>(null);
  const [thumbnailUploading, setThumbnailUploading] = useState(false);
  const [thumbnailGenerating, setThumbnailGenerating] = useState(false);
  const previewRef = useRef<string | null>(null);
  const autoGeneratedForRef = useRef<string | null>(null);

  const clearThumbnailPreview = useCallback(() => {
    if (previewRef.current) {
      URL.revokeObjectURL(previewRef.current);
      previewRef.current = null;
    }
    setThumbnailPreviewUrl(null);
    setThumbnailFileName(null);
  }, []);

  const {
    register,
    handleSubmit,
    setValue,
    reset,
    watch,
    formState: { errors }
  } = useUploadForm();

  const title = watch('title');
  const description = watch('description');
  const userContext = watch('userContext');

  const handleFileChange = useCallback(
    ({
      file: nextFile,
      durationSeconds: detectedDuration,
      suggestedTitle: suggested
    }: {
      file: File | null;
      durationSeconds: number | null;
      suggestedTitle?: string;
    }) => {
      setFile(nextFile);
      setDurationSeconds(detectedDuration);
      if (suggested) {
        setSuggestedTitle(suggested);
      }
    },
    []
  );

  const handleResetThumbnail = useCallback(() => {
    clearThumbnailPreview();
    autoGeneratedForRef.current = null;
    setThumbnailBlob(null);
    setThumbnailFileName(null);
    setThumbnailObjectKey(null);
    setThumbnailError(null);
    setThumbnailSource(null);
  }, [clearThumbnailPreview]);

  // Reset thumbnail state when base video file changes
  useEffect(() => {
    clearThumbnailPreview();
    autoGeneratedForRef.current = null;
    setThumbnailError(null);
    setThumbnailBlob(null);
    setThumbnailObjectKey(null);
    setThumbnailSource(null);
    setThumbnailGenerating(false);
    if (!file) {
      setDurationSeconds(null);
    }
  }, [clearThumbnailPreview, file]);

  useEffect(
    () => () => {
      clearThumbnailPreview();
    },
    [clearThumbnailPreview]
  );

  // Auto-generate thumbnail from selected video when no manual thumbnail is chosen
  useEffect(() => {
    if (!file || thumbnailSource === 'manual') return;
    const key = `${file.name}-${file.size}-${file.lastModified}`;
    if (thumbnailSource === 'auto' && autoGeneratedForRef.current === key && thumbnailPreviewUrl) {
      return;
    }
    autoGeneratedForRef.current = key;

    let cancelled = false;
    let videoUrl: string | null = null;

    const generate = () => {
      const videoEl = document.createElement('video');
      videoUrl = URL.createObjectURL(file);
      videoEl.src = videoUrl;
      videoEl.muted = true;
      videoEl.playsInline = true;
      videoEl.preload = 'auto';
      videoEl.crossOrigin = 'anonymous';
      setThumbnailGenerating(true);
      setThumbnailError(null);

      const cleanupVideoUrl = () => {
        if (videoUrl) {
          URL.revokeObjectURL(videoUrl);
          videoUrl = null;
        }
      };

      const capture = async (el: HTMLVideoElement) => {
        const sourceWidth = el.videoWidth || 640;
        const sourceHeight = el.videoHeight || 360;
        const targetWidth = 640;
        const targetHeight = 360;
        const targetAspect = targetWidth / targetHeight;
        const sourceAspect = sourceWidth / sourceHeight;

        let sx = 0;
        let sy = 0;
        let sw = sourceWidth;
        let sh = sourceHeight;
        if (sourceAspect > targetAspect) {
          sw = sourceHeight * targetAspect;
          sx = (sourceWidth - sw) / 2;
        } else {
          sh = sourceWidth / targetAspect;
          sy = (sourceHeight - sh) / 2;
        }

        const canvas = document.createElement('canvas');
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('Canvas unsupported');
        ctx.drawImage(el, sx, sy, sw, sh, 0, 0, targetWidth, targetHeight);

        const blob = await new Promise<Blob | null>((resolve) =>
          canvas.toBlob((b) => resolve(b), 'image/png')
        );
        if (!blob) throw new Error('Failed to create thumbnail blob');

        clearThumbnailPreview();
        const preview = URL.createObjectURL(blob);
        previewRef.current = preview;
        setThumbnailPreviewUrl(preview);
        setThumbnailFileName('Auto-generated thumbnail');
        setThumbnailBlob(blob);
        setThumbnailSource('auto');
        setThumbnailError(null);
      };

      videoEl.onloadeddata = () => {
        if (cancelled) return;
        videoEl.currentTime = 0.1;
      };
      videoEl.onseeked = async () => {
        if (cancelled) return;
        try {
          await capture(videoEl);
        } catch (error) {
          console.error('Auto thumbnail failed', error);
          setThumbnailError('自動サムネ生成に失敗しました（任意でアップロードしてください）');
          setThumbnailSource('auto');
        } finally {
          cleanupVideoUrl();
          setThumbnailGenerating(false);
        }
      };
      videoEl.onerror = () => {
        if (cancelled) return;
        setThumbnailError('動画からサムネを生成できませんでした');
        autoGeneratedForRef.current = key;
        setThumbnailSource('auto');
        cleanupVideoUrl();
        setThumbnailGenerating(false);
      };

      videoEl.load();
    };

    generate();

    return () => {
      cancelled = true;
      if (videoUrl) {
        URL.revokeObjectURL(videoUrl);
        videoUrl = null;
      }
      setThumbnailGenerating(false);
    };
  }, [file, thumbnailSource, thumbnailPreviewUrl, clearThumbnailPreview]);

  const handleManualThumbnail = (thumbFile: File | null) => {
    setThumbnailSource(thumbFile ? 'manual' : null);
    setThumbnailObjectKey(null);
    setThumbnailError(null);
    clearThumbnailPreview();
    if (!thumbFile) {
      setThumbnailBlob(null);
      setThumbnailFileName(null);
      return;
    }
    const preview = URL.createObjectURL(thumbFile);
    previewRef.current = preview;
    setThumbnailPreviewUrl(preview);
    setThumbnailFileName(thumbFile.name);
    setThumbnailBlob(thumbFile);
  };

  const uploadAndCreate = useMutation({
    mutationFn: async () => {
      if (!file) throw new Error('File is required');
      let thumbKey = thumbnailObjectKey;
      if (!thumbKey && thumbnailBlob) {
        setThumbnailUploading(true);
        const res = await apiClient<{ id: string; objectKey: string; status: string }>(
          '/uploads?kind=thumbnail',
          {
            method: 'POST',
            headers: {
              'Content-Type': thumbnailBlob.type || 'image/png'
            },
            body: thumbnailBlob
          }
        );
        thumbKey = res.objectKey;
        setThumbnailObjectKey(res.objectKey);
        setThumbnailUploading(false);
      }
      const upload = await createUploadSession(file);
      const video = await apiClient<VideoSummary>('/videos', {
        method: 'POST',
        body: JSON.stringify({
          uploadId: upload.id,
          title: title || file.name,
          description: description || 'Uploaded video',
          durationSeconds: durationSeconds ?? 60,
          thumbnailObjectKey: thumbKey
        })
      });
      return { uploadId: upload.id, video };
    },
    onSuccess: () => {
      client.invalidateQueries({ queryKey: ['videos'] });
      client.invalidateQueries({ queryKey: ['uploads'] });
      setFile(null);
      setDurationSeconds(null);
      setSuggestedTitle(undefined);
      setThumbnailBlob(null);
      setThumbnailObjectKey(null);
      setThumbnailSource(null);
      setThumbnailError(null);
      setThumbnailGenerating(false);
      clearThumbnailPreview();
      reset({
        title: '',
        description: '',
        tone: 'friendly',
        userContext: ''
      });
    }
  });

  const disabled = !file || uploadAndCreate.isPending || creating;
  const selectedName = useMemo(() => file?.name ?? '', [file]);
  return (
    <section className="space-y-6">
      <PageHeader
        title="Upload"
        description="流れ: 1) 動画選択 → 2) サムネ確認 → 3) タイトル/説明 → 4) Upload/登録"
      />
      <div className="grid gap-5 lg:grid-cols-[2fr_1fr]">
        <div className="space-y-5">
          <Card className="border-border/80">
            <CardHeader className="pb-3">
              <div className="flex flex-col gap-1">
                <p className="text-xs font-semibold uppercase tracking-wide text-muted-foreground">Step 1</p>
                <CardTitle className="text-xl">動画ファイルを選択</CardTitle>
              </div>
            </CardHeader>
            <CardContent className="space-y-2 pt-0">
              <FilePicker file={file} onChange={handleFileChange} />
              {selectedName && (
                <div className="flex justify-end text-xs text-muted-foreground">
                  <p>動画時間: {durationSeconds ? `${durationSeconds} sec` : '検出中…'}</p>
                </div>
              )}
            </CardContent>
          </Card>

          <ThumbnailSection
            previewUrl={thumbnailPreviewUrl}
            fileName={thumbnailFileName}
            error={thumbnailError}
            generating={thumbnailGenerating}
            uploading={thumbnailUploading}
            objectKey={thumbnailObjectKey}
            source={thumbnailSource}
            onResetToAuto={handleResetThumbnail}
            onSelect={handleManualThumbnail}
          />

          <Card className="border-border/80">
            <CardHeader className="pb-3">
              <div className="flex flex-col gap-1">
                <p className="text-xs font-semibold uppercase tracking-wide text-muted-foreground">Step 3</p>
                <CardTitle className="text-xl">タイトル・説明を整える</CardTitle>
              </div>
            </CardHeader>
            <CardContent className="space-y-4 pt-0">
              <div className="grid gap-4 lg:grid-cols-[1.5fr_1fr]">
                <TextInputs
                  register={register}
                  errors={errors}
                  suggestedTitle={suggestedTitle}
                  setValue={setValue}
                />
                <AiCopySection
                  file={file}
                  onApply={(copy) => {
                    setValue('title', copy.title, { shouldValidate: true });
                    setValue('description', copy.description, { shouldValidate: true });
                  }}
                  register={register}
                  errors={errors}
                  userContextValue={userContext}
                />
              </div>
            </CardContent>
          </Card>

          <Card className="border-border/80">
            <CardHeader className="pb-3">
              <div className="flex flex-col gap-1">
                <p className="text-xs font-semibold uppercase tracking-wide text-muted-foreground">Step 4</p>
                <CardTitle className="text-xl">アップロードして登録</CardTitle>
              </div>
            </CardHeader>
            <CardContent className="flex flex-wrap items-start gap-3 pt-0">
              <Button disabled={disabled} onClick={handleSubmit(() => uploadAndCreate.mutate())}>
                {uploadAndCreate.isPending ? 'Uploading…' : 'Upload & Register'}
              </Button>
              <div className="space-y-1 text-sm text-muted-foreground">
                <p>内容を確認してから実行してください。</p>
                {uploadAndCreate.isError && (
                  <p className="text-danger">Failed to upload. Please retry.</p>
                )}
                {uploadAndCreate.isSuccess && uploadAndCreate.data && (
                  <p className="text-success">
                    Uploaded and registered! Video ID: {uploadAndCreate.data.video.id}
                  </p>
                )}
              </div>
            </CardContent>
          </Card>
        </div>

        <div className="space-y-5 lg:sticky lg:top-4">
          <RecentUploadsAccordion />
        </div>
      </div>
    </section>
  );
};
