import { useMutation, useQueryClient } from '@tanstack/react-query'
import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import { AiCopySection } from '@/components/features/upload/components/AiCopySection'
import { FilePicker } from '@/components/features/upload/components/FilePicker'
import { RecentUploadsAccordion } from '@/components/features/upload/components/RecentUploadsAccordion'
import { TextInputs } from '@/components/features/upload/components/TextInputs'
import { ThumbnailSection } from '@/components/features/upload/components/ThumbnailSection'
import { useUploadSessions } from '@/components/features/upload/hooks/useUploadSessions'
import { useUploadForm } from '@/components/features/upload/useUploadForm'
import { PageHeader } from '@/components/layout/PageHeader'
import { useToast } from '@/components/shadcn/hooks/useToast'
import { Button, Card, CardContent, CardHeader, CardTitle } from '@/components/ui'
import { apiClient } from '@/lib/api-client'
import type { VideoSummary } from '@/types/video'

export const UploadPage = () => {
  const client = useQueryClient()
  const { create: createUploadSession, creating } = useUploadSessions()
  const toast = useToast()

  const [file, setFile] = useState<File | null>(null)
  const [durationSeconds, setDurationSeconds] = useState<number | null>(null)
  const [suggestedTitle, setSuggestedTitle] = useState<string | undefined>(undefined)
  const [thumbnailSource, setThumbnailSource] = useState<'auto' | 'manual' | null>(null)
  const [thumbnailBlob, setThumbnailBlob] = useState<Blob | null>(null)
  const [thumbnailPreviewUrl, setThumbnailPreviewUrl] = useState<string | null>(null)
  const [thumbnailFileName, setThumbnailFileName] = useState<string | null>(null)
  const [thumbnailError, setThumbnailError] = useState<string | null>(null)
  const [thumbnailObjectKey, setThumbnailObjectKey] = useState<string | null>(null)
  const [thumbnailUploading, setThumbnailUploading] = useState(false)
  const [thumbnailGenerating, setThumbnailGenerating] = useState(false)
  const previewRef = useRef<string | null>(null)
  const autoGeneratedForRef = useRef<string | null>(null)

  const clearThumbnailPreview = useCallback(() => {
    if (previewRef.current) {
      URL.revokeObjectURL(previewRef.current)
      previewRef.current = null
    }
    setThumbnailPreviewUrl(null)
    setThumbnailFileName(null)
  }, [])

  const {
    register,
    handleSubmit,
    setValue,
    reset,
    watch,
    formState: { errors },
  } = useUploadForm()

  const title = watch('title')
  const description = watch('description')
  const userContext = watch('userContext')

  const handleFileChange = useCallback(
    ({
      file: nextFile,
      durationSeconds: detectedDuration,
      suggestedTitle: suggested,
    }: {
      file: File | null
      durationSeconds: number | null
      suggestedTitle?: string
    }) => {
      setFile(nextFile)
      setDurationSeconds(detectedDuration)
      if (suggested) {
        setSuggestedTitle(suggested)
      }
    },
    [],
  )

  const handleResetThumbnail = useCallback(() => {
    clearThumbnailPreview()
    autoGeneratedForRef.current = null
    setThumbnailBlob(null)
    setThumbnailFileName(null)
    setThumbnailObjectKey(null)
    setThumbnailError(null)
    setThumbnailSource(null)
  }, [clearThumbnailPreview])

  // Reset thumbnail state when base video file changes
  useEffect(() => {
    clearThumbnailPreview()
    autoGeneratedForRef.current = null
    setThumbnailError(null)
    setThumbnailBlob(null)
    setThumbnailObjectKey(null)
    setThumbnailSource(null)
    setThumbnailGenerating(false)
    if (!file) {
      setDurationSeconds(null)
    }
  }, [clearThumbnailPreview, file])

  useEffect(
    () => () => {
      clearThumbnailPreview()
    },
    [clearThumbnailPreview],
  )

  // Auto-generate thumbnail from selected video when no manual thumbnail is chosen
  useEffect(() => {
    if (!file || thumbnailSource === 'manual') return
    const key = `${file.name}-${file.size}-${file.lastModified}`
    if (thumbnailSource === 'auto' && autoGeneratedForRef.current === key && thumbnailPreviewUrl) {
      return
    }
    autoGeneratedForRef.current = key

    let cancelled = false
    let videoUrl: string | null = null

    const generate = () => {
      const videoEl = document.createElement('video')
      videoUrl = URL.createObjectURL(file)
      videoEl.src = videoUrl
      videoEl.muted = true
      videoEl.playsInline = true
      videoEl.preload = 'auto'
      videoEl.crossOrigin = 'anonymous'
      setThumbnailGenerating(true)
      setThumbnailError(null)

      const cleanupVideoUrl = () => {
        if (videoUrl) {
          URL.revokeObjectURL(videoUrl)
          videoUrl = null
        }
      }

      const capture = async (el: HTMLVideoElement) => {
        const sourceWidth = el.videoWidth || 640
        const sourceHeight = el.videoHeight || 360
        const targetWidth = 640
        const targetHeight = 360
        const targetAspect = targetWidth / targetHeight
        const sourceAspect = sourceWidth / sourceHeight

        let sx = 0
        let sy = 0
        let sw = sourceWidth
        let sh = sourceHeight
        if (sourceAspect > targetAspect) {
          sw = sourceHeight * targetAspect
          sx = (sourceWidth - sw) / 2
        } else {
          sh = sourceWidth / targetAspect
          sy = (sourceHeight - sh) / 2
        }

        const canvas = document.createElement('canvas')
        canvas.width = targetWidth
        canvas.height = targetHeight
        const ctx = canvas.getContext('2d')
        if (!ctx) throw new Error('Canvas unsupported')
        ctx.drawImage(el, sx, sy, sw, sh, 0, 0, targetWidth, targetHeight)

        const blob = await new Promise<Blob | null>((resolve) =>
          canvas.toBlob((b) => resolve(b), 'image/png'),
        )
        if (!blob) throw new Error('Failed to create thumbnail blob')

        clearThumbnailPreview()
        const preview = URL.createObjectURL(blob)
        previewRef.current = preview
        setThumbnailPreviewUrl(preview)
        setThumbnailFileName('自動生成サムネイル')
        setThumbnailBlob(blob)
        setThumbnailSource('auto')
        setThumbnailError(null)
      }

      videoEl.onloadeddata = () => {
        if (cancelled) return
        videoEl.currentTime = 0.1
      }
      videoEl.onseeked = async () => {
        if (cancelled) return
        try {
          await capture(videoEl)
        } catch (error) {
          console.error('Auto thumbnail failed', error)
          setThumbnailError('自動サムネ生成に失敗しました（任意でアップロードしてください）')
          setThumbnailSource('auto')
        } finally {
          cleanupVideoUrl()
          setThumbnailGenerating(false)
        }
      }
      videoEl.onerror = () => {
        if (cancelled) return
        setThumbnailError('動画からサムネを生成できませんでした')
        autoGeneratedForRef.current = key
        setThumbnailSource('auto')
        cleanupVideoUrl()
        setThumbnailGenerating(false)
      }

      videoEl.load()
    }

    generate()

    return () => {
      cancelled = true
      if (videoUrl) {
        URL.revokeObjectURL(videoUrl)
        videoUrl = null
      }
      setThumbnailGenerating(false)
    }
  }, [file, thumbnailSource, thumbnailPreviewUrl, clearThumbnailPreview])

  const handleManualThumbnail = (thumbFile: File | null) => {
    setThumbnailSource(thumbFile ? 'manual' : null)
    setThumbnailObjectKey(null)
    setThumbnailError(null)
    clearThumbnailPreview()
    if (!thumbFile) {
      setThumbnailBlob(null)
      setThumbnailFileName(null)
      return
    }
    const preview = URL.createObjectURL(thumbFile)
    previewRef.current = preview
    setThumbnailPreviewUrl(preview)
    setThumbnailFileName(thumbFile.name)
    setThumbnailBlob(thumbFile)
  }

  const uploadAndCreate = useMutation({
    mutationFn: async () => {
      if (!file) throw new Error('File is required')
      let thumbKey = thumbnailObjectKey
      if (!thumbKey && thumbnailBlob) {
        setThumbnailUploading(true)
        const res = await apiClient<{
          id: string
          objectKey: string
          status: string
        }>('/uploads?kind=thumbnail', {
          method: 'POST',
          headers: {
            'Content-Type': thumbnailBlob.type || 'image/png',
          },
          body: thumbnailBlob,
        })
        thumbKey = res.objectKey
        setThumbnailObjectKey(res.objectKey)
        setThumbnailUploading(false)
      }
      const upload = await createUploadSession(file)
      const video = await apiClient<VideoSummary>('/videos', {
        method: 'POST',
        body: JSON.stringify({
          uploadId: upload.id,
          title: title || file.name,
          description: description || 'Uploaded video',
          durationSeconds: durationSeconds ?? 60,
          thumbnailObjectKey: thumbKey,
        }),
      })
      return { uploadId: upload.id, video }
    },
    onSuccess: (result) => {
      toast.success('アップロードが完了しました', {
        description: `Video ID: ${result.video.id}`,
      })
      client.invalidateQueries({ queryKey: ['videos'] })
      client.invalidateQueries({ queryKey: ['uploads'] })
      setFile(null)
      setDurationSeconds(null)
      setSuggestedTitle(undefined)
      setThumbnailBlob(null)
      setThumbnailObjectKey(null)
      setThumbnailSource(null)
      setThumbnailError(null)
      setThumbnailGenerating(false)
      clearThumbnailPreview()
      reset({
        title: '',
        description: '',
        tone: 'friendly',
        userContext: '',
      })
    },
    onError: () => {
      toast.error('アップロードに失敗しました', {
        description: '時間をおいて再試行してください',
      })
    },
  })

  const disabled = !file || uploadAndCreate.isPending || creating
  const selectedName = useMemo(() => file?.name ?? '', [file])
  return (
    <section className='space-y-6'>
      <PageHeader
        title='アップロード'
        description='流れ: 1) 動画選択 → 2) サムネ確認 → 3) タイトル/説明 → 4) アップロード/登録'
      />
      <div className='grid gap-5 lg:grid-cols-[2fr_1fr]'>
        <div className='space-y-5'>
          <Card className='border-border/80'>
            <CardHeader className='pb-3'>
              <div className='flex flex-col gap-1'>
                <p className='text-xs font-semibold uppercase tracking-wide text-muted-foreground'>
                  ステップ 1
                </p>
                <CardTitle className='text-xl'>動画ファイルを選択</CardTitle>
              </div>
            </CardHeader>
            <CardContent className='space-y-2 pt-0'>
              <FilePicker file={file} onChange={handleFileChange} />
              {selectedName && (
                <div className='flex justify-end text-xs text-muted-foreground'>
                  <p>動画時間: {durationSeconds ? `${durationSeconds} 秒` : '検出中…'}</p>
                </div>
              )}
            </CardContent>
          </Card>

          <ThumbnailSection
            previewUrl={thumbnailPreviewUrl}
            fileName={thumbnailFileName}
            error={thumbnailError}
            generating={thumbnailGenerating}
            uploading={thumbnailUploading}
            objectKey={thumbnailObjectKey}
            source={thumbnailSource}
            onResetToAuto={handleResetThumbnail}
            onSelect={handleManualThumbnail}
          />

          <Card className='border-border/80'>
            <CardHeader className='pb-3'>
              <div className='flex flex-col gap-1'>
                <p className='text-xs font-semibold uppercase tracking-wide text-muted-foreground'>
                  ステップ 3
                </p>
                <CardTitle className='text-xl'>タイトル・説明を整える</CardTitle>
              </div>
            </CardHeader>
            <CardContent className='space-y-4 pt-0'>
              <div className='grid gap-4 lg:grid-cols-[1.5fr_1fr]'>
                <TextInputs
                  register={register}
                  errors={errors}
                  suggestedTitle={suggestedTitle}
                  setValue={setValue}
                />
                <AiCopySection
                  file={file}
                  onApply={(copy) => {
                    setValue('title', copy.title, { shouldValidate: true })
                    setValue('description', copy.description, {
                      shouldValidate: true,
                    })
                  }}
                  register={register}
                  errors={errors}
                  userContextValue={userContext}
                />
              </div>
            </CardContent>
          </Card>

          <Card className='border-border/80'>
            <CardHeader className='pb-3'>
              <div className='flex flex-col gap-1'>
                <p className='text-xs font-semibold uppercase tracking-wide text-muted-foreground'>
                  ステップ 4
                </p>
                <CardTitle className='text-xl'>アップロードして登録</CardTitle>
              </div>
            </CardHeader>
            <CardContent className='flex flex-wrap items-start gap-3 pt-0'>
              <Button disabled={disabled} onClick={handleSubmit(() => uploadAndCreate.mutate())}>
                {uploadAndCreate.isPending ? 'アップロード中…' : 'アップロードして登録'}
              </Button>
              <div className='space-y-1 text-sm text-muted-foreground'>
                <p>内容を確認してから実行してください。</p>
              </div>
            </CardContent>
          </Card>
        </div>

        <div className='space-y-5 lg:sticky lg:top-4'>
          <RecentUploadsAccordion />
        </div>
      </div>
    </section>
  )
}
